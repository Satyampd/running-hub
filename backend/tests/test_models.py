from app.models.club import Club
from app.models.event import Event
import uuid
from datetime import datetime
from sqlalchemy.orm import declarative_base
from sqlalchemy import Column, Integer, String as SAString # Avoid conflict with python String

def test_create_club_instance():
    """Test creating an instance of the Club model."""
    club_data = {
        "id": "test_club_001",
        "name": "Test Runners Club",
        "location": "Test City",
        "description": "A club for testing purposes.",
        "contact_email": "test@example.com",
        "skill_level": "Beginner"
    }
    club = Club(**club_data)

    assert club.id == club_data["id"]
    assert club.name == club_data["name"]
    assert club.location == club_data["location"]
    assert club.description == club_data["description"]
    assert club.contact_email == club_data["contact_email"]
    assert club.skill_level == club_data["skill_level"]
    # Test default values (attributes are None before DB commit if only server_default is used)
    assert club.meeting_times is None
    assert club.social_media is None
    assert club.photos is None
    assert club.amenities is None

    # Test optional fields not provided
    assert club.address is None
    assert club.established_year is None
    assert club.contact_phone is None
    assert club.website_url is None
    assert club.membership_fee is None
    assert club.typical_routes is None
    assert club.group_size is None
    assert club.logo_url is None

def test_club_nullable_fields():
    """Test that non-nullable fields raise an error or are handled by SQLAlchemy if set to None,
       though direct None assignment tests are more for ORM interaction tests.
       Here, we primarily check if defaults work as expected or if they can be None if allowed."""
    # This test is more conceptual for model unit tests without DB interaction.
    # SQLAlchemy handles nullable constraints at the DB level or during flush/commit.
    # For a pure Python object test, we mainly check initial state or if defaults are applied.

    club_data_minimal = {
        "id": "test_club_002",
        "name": "Minimal Club",
        "location": "Anytown",
        "description": "Minimal description.",
        "contact_email": "minimal@example.com",
        "skill_level": "All"
    }
    club = Club(**club_data_minimal)
    assert club.name == "Minimal Club" # Not null
    assert club.address is None # Nullable field is None

    # Example of how SQLAlchemy might behave (conceptual)
    # with pytest.raises(IntegrityError): # This would require a DB session
    #     club_missing_required = Club(id="test003", location="Testville") # Missing name, description etc.
    #     # session.add(club_missing_required)
    #     # session.commit()

def test_event_id_generation():
    """Test that Event ID is generated by default."""
    print(f"Event.id.default: {Event.id.default}")
    print(f"Event.categories.default: {Event.categories.default}")
    event_minimal = Event(
        title="Minimal Event",
        date="2025-01-01",
        location="Test Location",
        url="http://example.com/minimal",
        source="Test Source"
    )
    assert isinstance(event_minimal.id, uuid.UUID), f"event_minimal.id is {type(event_minimal.id)}, value {event_minimal.id}"

def test_create_event_instance():
    """Test creating an instance of the Event model and its default values."""
    event_data = {
        "title": "Annual Marathon Challenge",
        "date": "2024-12-31",
        "location": "Central Park",
        "url": "http://example.com/marathon",
        "source": "Example Events"
    }
    event = Event(**event_data)

    assert isinstance(event.id, uuid.UUID), f"event.id is {type(event.id)}, value {event.id}"
    assert event.title == event_data["title"]
    assert event.date == event_data["date"]
    assert event.location == event_data["location"]
    assert event.url == event_data["url"]
    assert event.source == event_data["source"]
    assert event.categories == []
    assert event.price == "Price TBD"
    assert event.is_verified is False
    assert isinstance(event.created_at, datetime)
    assert isinstance(event.updated_at, datetime)
    assert event.address is None
    assert event.description is None
    assert event.registration_closes is None
    assert event.scraped_at is None
    assert event.image_url is None

def test_event_with_specific_id():
    """Test creating an Event instance with a specific ID."""
    specific_id = uuid.uuid4()
    event_data = {
        "id": specific_id,
        "title": "Sprint Race",
        "date": "2024-10-15",
        "location": "Track Field",
        "url": "http://example.com/sprint",
        "source": "Local Races"
    }
    event = Event(**event_data)
    assert event.id == specific_id

# --- Test for basic SQLAlchemy default behavior ---
MiniBase = declarative_base()

class TestDefaultModel(MiniBase):
    __tablename__ = "test_default_model"
    id = Column(Integer, primary_key=True) # Auto-increment, not a client-side default test here
    data = Column(SAString, default="default_value")
    counter = Column(Integer, default=lambda: 100)
    uid = Column(SAString, default=lambda: str(uuid.uuid4()))

def test_standalone_model_defaults():
    """Test if a standalone simple model respects client-side defaults."""
    instance = TestDefaultModel()
    assert instance.data == "default_value"
    assert instance.counter == 100
    assert isinstance(uuid.UUID(instance.uid), uuid.UUID) # Check if it's a valid UUID string

    instance_with_data = TestDefaultModel(data="custom_value", counter=50, uid="custom_uid")
    assert instance_with_data.data == "custom_value"
    assert instance_with_data.counter == 50
    assert instance_with_data.uid == "custom_uid" 